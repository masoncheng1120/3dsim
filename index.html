<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Trigonometry Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f3f4f6; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        .panel {
            backdrop-filter: blur(10px);
            background-color: rgba(255, 255, 255, 0.95);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body>

    <!-- UI Overlay -->
    <div class="absolute top-4 left-4 z-10 w-80 panel rounded-xl p-6 border border-gray-200 overflow-y-auto max-h-[90vh]">
        <h1 class="text-xl font-bold text-gray-800 mb-4">3D Trigonometry</h1>

        <!-- Mode Selection -->
        <div class="mb-6">
            <label class="block text-xs font-bold text-gray-500 uppercase tracking-wide mb-2">Select Concept</label>
            <div class="flex flex-col gap-2 bg-gray-100 p-2 rounded-lg">
                <div class="flex gap-2">
                    <!-- HIDDEN as requested -->
                    <button id="mode-planes" class="hidden flex-1 py-1.5 px-2 rounded-md text-xs font-semibold bg-white shadow-sm text-gray-800 transition-all">Two Planes</button>
                    <button id="mode-pyramid" class="hidden flex-1 py-1.5 px-2 rounded-md text-xs font-semibold text-gray-500 hover:text-gray-700 transition-all">Pyramid</button>
                </div>
                <div class="flex gap-2">
                    <!-- HIDDEN as requested -->
                    <button id="mode-line" class="hidden flex-1 py-1.5 px-2 rounded-md text-xs font-semibold text-gray-500 hover:text-gray-700 transition-all">Line & Plane</button>
                    <!-- Visible Modes -->
                    <button id="mode-box" class="flex-1 py-1.5 px-2 rounded-md text-xs font-semibold text-gray-500 hover:text-gray-700 transition-all">Rect Prism</button>
                    <button id="mode-tri-prism" class="flex-1 py-1.5 px-1 rounded-md text-xs font-semibold text-gray-500 hover:text-gray-700 transition-all">Tri Prism</button>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="space-y-6">

            <!-- Planes Mode Controls (Hidden effectively by logic) -->
            <div id="control-shapes" class="hidden">
                <label class="block text-sm font-semibold text-gray-700 mb-2">Plane Shapes</label>
                <div class="relative">
                    <select id="shape-select" class="block w-full px-3 py-2 text-sm text-gray-700 bg-gray-50 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 outline-none appearance-none">
                        <option value="rect-rect">Two Rectangles (Book)</option>
                        <option value="tri-rect">Triangle & Rectangle</option>
                        <option value="tri-tri">Two Triangles</option>
                        <option value="tri-irregular">Irregular Tri & Rectangle</option>
                    </select>
                    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700">
                        <svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                    </div>
                </div>
                <button id="btn-randomize" class="mt-2 w-full bg-blue-100 text-blue-700 px-3 py-1.5 rounded-md text-xs font-bold hover:bg-blue-200 transition-colors hidden">
                    ðŸŽ² Randomize Top Shape
                </button>
            </div>

            <!-- Pyramid Mode Controls (Hidden) -->
            <div id="control-pyramid-options" class="hidden">
               <!-- ... existing pyramid controls ... -->
            </div>

            <!-- Line Mode Controls (Hidden effectively) -->
            <div id="control-line-options" class="hidden">
                <!-- ... existing line controls ... -->
                <label class="block text-sm font-semibold text-gray-700 mb-2">Plane Orientation</label>
                <div class="relative mb-4">
                    <select id="line-orientation" class="block w-full px-3 py-2 text-sm text-gray-700 bg-gray-50 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 outline-none appearance-none">
                        <option value="floor">Floor (Horizontal)</option>
                        <option value="wall">Wall (Vertical)</option>
                    </select>
                </div>
                <label class="flex justify-between text-sm font-semibold text-gray-700 mb-1">
                    <span>Line Direction</span>
                    <span id="label-direction" class="text-blue-600">0Â°</span>
                </label>
                <input type="range" id="input-direction" min="0" max="360" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
            </div>

            <!-- Box/Prism Mode Controls -->
            <div id="control-box-options" class="hidden">
                
                <!-- Function Toggle -->
                <div class="flex bg-gray-200 p-1 rounded-lg mb-4">
                    <button id="btn-func-shape" class="flex-1 py-1 px-2 rounded text-xs font-bold bg-white shadow-sm text-blue-600 transition-all">Define Plane</button>
                    <button id="btn-func-measure" class="flex-1 py-1 px-2 rounded text-xs font-bold text-gray-500 hover:text-gray-700 transition-all">Measure Angle</button>
                </div>

                <!-- Shape/Plane Definition Mode -->
                <div id="box-ui-shape">
                    <p class="text-xs text-gray-500 italic mb-4">Select 3 nodes to create a plane.</p>
                </div>

                <!-- Measure Mode -->
                <div id="box-ui-measure" class="hidden">
                    <p id="measure-instruction" class="text-xs text-blue-600 font-bold italic mb-2">Step 1: Select 2 points for the Line</p>
                    <div class="flex gap-2 mb-4">
                        <button id="btn-measure-next" class="flex-1 bg-blue-600 text-white py-1 px-2 rounded text-xs font-bold hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>Next: Select Plane</button>
                        <button id="btn-measure-reset" class="px-3 bg-gray-200 text-gray-600 py-1 rounded text-xs font-bold hover:bg-gray-300">Reset</button>
                    </div>
                </div>

                <!-- Node Selection Grid -->
                <div class="grid grid-cols-4 gap-2 mb-4">
                    <div id="node-checkboxes" class="contents"></div>
                </div>

                <div class="space-y-4 pt-2 border-t border-gray-100">
                    <div>
                        <label class="flex justify-between text-sm font-semibold text-gray-700 mb-1">
                            <span>Width (X)</span>
                            <span id="label-box-w" class="text-blue-600">4.0</span>
                        </label>
                        <input type="range" id="input-box-w" min="2" max="6" step="0.5" value="4" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                    </div>
                    <div>
                        <label class="flex justify-between text-sm font-semibold text-gray-700 mb-1">
                            <span>Height (Y)</span>
                            <span id="label-box-h" class="text-blue-600">3.0</span>
                        </label>
                        <input type="range" id="input-box-h" min="2" max="6" step="0.5" value="3" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                    </div>
                    <div>
                        <label class="flex justify-between text-sm font-semibold text-gray-700 mb-1">
                            <span>Length (Z)</span>
                            <span id="label-box-d" class="text-blue-600">3.0</span>
                        </label>
                        <input type="range" id="input-box-d" min="2" max="6" step="0.5" value="3" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                    </div>
                </div>
            </div>
            
            <!-- Angle Control (Standard) -->
            <div id="control-main-angle">
                <label class="flex justify-between text-sm font-semibold text-gray-700 mb-1">
                    <span id="label-angle-title">Opening Angle</span>
                    <span id="label-plane-angle" class="text-blue-600">45Â°</span>
                </label>
                <input type="range" id="input-plane-angle" min="10" max="80" value="45" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
            </div>

            <!-- Path/Skew Control -->
            <div id="control-skew">
                <label class="flex justify-between text-sm font-semibold text-gray-700 mb-1">
                    <span id="label-skew-title">Measurement Path</span>
                    <span id="label-skew" class="text-gray-500">Perpendicular</span>
                </label>
                <input type="range" id="input-skew" min="0" max="3" step="0.1" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-red-500">
                <p id="hint-skew" class="text-xs text-gray-500 mt-1">Slide right to measure diagonally.</p>
            </div>

            <!-- 2D Representation -->
            <div id="panel-2d" class="bg-gray-50 rounded-lg p-3 border border-gray-200">
                <label id="label-2d-title" class="block text-xs font-bold text-gray-600 mb-2 text-center">2D View</label>
                <canvas id="triangle-2d" width="240" height="140" class="mx-auto"></canvas>
            </div>

            <!-- Toggles -->
            <div id="control-slice-toggle" class="flex items-center justify-between pt-2">
                <span class="text-sm font-medium text-gray-700">Show Slicing Plane</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggle-slice" class="sr-only peer">
                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                </label>
            </div>

        </div>

        <!-- Result Display -->
        <div id="panel-results" class="mt-6 pt-6 border-t border-gray-200">
            <div class="flex justify-between items-end mb-2">
                <span id="label-result-title" class="text-sm text-gray-600">Target Angle:</span>
                <span id="display-measured-angle" class="text-2xl font-bold text-green-600">?</span>
            </div>
            <div class="flex justify-between items-end mb-2">
                <span id="label-result-extra" class="text-sm text-gray-600">Hypotenuse Length:</span>
                <span id="display-line-length" class="text-lg font-bold text-gray-800">10.0</span>
            </div>
            <div id="status-message" class="text-xs font-bold text-green-600 bg-green-100 p-2 rounded text-center">
                PROJECTION VISUALIZED
            </div>
            <p id="status-explanation" class="text-xs text-gray-500 mt-2 leading-relaxed">
                The angle is between the line and its orthogonal projection onto the selected plane.
            </p>
        </div>
    </div>

    <!-- Legend -->
    <div id="panel-legend" class="absolute bottom-4 right-4 z-10 panel rounded-lg p-4 text-xs space-y-2 border border-gray-200">
        <div id="legend-p1" class="flex items-center">
            <div class="w-3 h-3 bg-blue-400 mr-2 rounded-sm opacity-50"></div> <span id="legend-p1-text">Plane 1 (Top)</span>
        </div>
        <div class="flex items-center">
            <div class="w-3 h-3 bg-green-400 mr-2 rounded-sm opacity-50"></div> <span id="legend-p2-text">Plane 2 (Ground)</span>
        </div>
        <div id="legend-spine" class="flex items-center">
            <div class="w-8 h-0.5 bg-black mr-2"></div> <span id="legend-spine-text">Intersection (Edge)</span>
        </div>
        <div id="legend-true" class="flex items-center">
            <div class="w-8 h-1 bg-red-500 mr-2 rounded-full"></div> <span id="legend-true-text">True Angle Line</span>
        </div>
        <div id="legend-measure" class="flex items-center">
            <div class="w-8 h-1 bg-yellow-600 mr-2 rounded-full border border-yellow-700"></div> <span>Measured Line</span>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script>
        // --- Setup Three.js ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf3f4f6);
        scene.fog = new THREE.Fog(0xf3f4f6, 10, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 6, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- DOM Elements References ---
        const btnPlanes = document.getElementById('mode-planes');
        const btnPyramid = document.getElementById('mode-pyramid');
        const btnLine = document.getElementById('mode-line');
        const btnBox = document.getElementById('mode-box');
        const btnTriPrism = document.getElementById('mode-tri-prism');
        
        const shapeControl = document.getElementById('control-shapes');
        const lineControl = document.getElementById('control-line-options');
        const pyramidControl = document.getElementById('control-pyramid-options');
        const boxControl = document.getElementById('control-box-options');
        const mainAngleControl = document.getElementById('control-main-angle');
        const skewControl = document.getElementById('control-skew');
        const sliceToggleControl = document.getElementById('control-slice-toggle');
        
        const panel2D = document.getElementById('panel-2d');
        const panelResults = document.getElementById('panel-results');
        const panelLegend = document.getElementById('panel-legend');

        const lblSkew = document.getElementById('label-skew-title');
        const hintSkew = document.getElementById('hint-skew');
        const lbl2d = document.getElementById('label-2d-title');
        const lblAngle = document.getElementById('label-angle-title');
        const lblExtra = document.getElementById('label-result-extra');

        // New Box Mode Controls
        const btnFuncShape = document.getElementById('btn-func-shape');
        const btnFuncMeasure = document.getElementById('btn-func-measure');
        const boxUiShape = document.getElementById('box-ui-shape');
        const boxUiMeasure = document.getElementById('box-ui-measure');
        const measureInstruction = document.getElementById('measure-instruction');
        const btnMeasureNext = document.getElementById('btn-measure-next');
        const btnMeasureReset = document.getElementById('btn-measure-reset');

        // --- Interaction Globals ---
        let selectedNodes = [];
        let measureState = {
            active: false,
            step: 0, // 0: Select Line (2pts), 1: Select Plane (3 or 4 pts), 2: Result
            line: [],
            plane: []
        };
        
        // Node Mapping
        const nodeMap = { 'A': 7, 'B': 4, 'C': 5, 'D': 6, 'E': 3, 'F': 0, 'G': 1, 'H': 2 };
        const nodeLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
        const reverseNodeMap = { 7: 'A', 4: 'B', 5: 'C', 6: 'D', 3: 'E', 0: 'F', 1: 'G', 2: 'H' };

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // --- Helpers ---
        const gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xe5e7eb);
        scene.add(gridHelper);

        // --- Objects Container ---
        const bookGroup = new THREE.Group();
        scene.add(bookGroup);

        // --- Geometries ---
        const spineGeo = new THREE.CylinderGeometry(0.05, 0.05, 6, 16);
        const spineMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const spine = new THREE.Mesh(spineGeo, spineMat);
        spine.rotation.x = Math.PI / 2; 
        bookGroup.add(spine);

        const planeWidth = 4;
        const planeHeight = 4;
        const rectGeo = new THREE.BufferGeometry();
        rectGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array([0,0,-2, 4,0,-2, 0,0,2, 4,0,2]), 3));
        rectGeo.setIndex([0, 2, 1, 2, 3, 1]);
        rectGeo.computeVertexNormals();

        const groundGeo = new THREE.PlaneGeometry(10, 10);
        const triGeo = new THREE.BufferGeometry();
        triGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array([0,0,-2, 0,0,2, 4,0,0]), 3));
        triGeo.setIndex([0, 1, 2]);
        triGeo.computeVertexNormals();

        function createIrregularTriGeometry(width, tipZOffset) {
            const g = new THREE.BufferGeometry();
            g.setAttribute('position', new THREE.BufferAttribute(new Float32Array([0,0,-2, 0,0,2, width,0,tipZOffset]), 3));
            g.setIndex([0, 1, 2]);
            g.computeVertexNormals();
            return g;
        }

        const matPlane1 = new THREE.MeshStandardMaterial({ color: 0x60a5fa, side: THREE.DoubleSide, transparent: true, opacity: 0.8, roughness: 0.1 });
        const matPlane2 = new THREE.MeshStandardMaterial({ color: 0x4ade80, side: THREE.DoubleSide, transparent: true, opacity: 0.8, roughness: 0.1 });
        const matPrism = new THREE.MeshStandardMaterial({ color: 0xe0e7ff, side: THREE.DoubleSide, transparent: true, opacity: 0.5, roughness: 0.1 });

        const plane1 = new THREE.Mesh(rectGeo, matPlane1);
        const plane2 = new THREE.Mesh(rectGeo, matPlane2);
        bookGroup.add(plane1);
        bookGroup.add(plane2);

        // Assets for Prism/Box
        const boxEdgesMesh = new THREE.LineSegments(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 }));
        scene.add(boxEdgesMesh);
        
        const nodesGroup = new THREE.Group();
        scene.add(nodesGroup);
        const nodeMeshes = [];
        const nodeSprites = []; 

        function createLabel(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "rgba(0,0,0,0)";
            ctx.font = "Bold 40px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "black";
            ctx.fillText(text, 32, 32);
            const tex = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, depthTest: false }));
            return sprite;
        }

        for(let i=0; i<8; i++) {
            const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), new THREE.MeshBasicMaterial({ color: 0x9ca3af }));
            nodeMeshes.push(sphere);
            nodesGroup.add(sphere);
            const lbl = createLabel(reverseNodeMap[i]);
            scene.add(lbl);
            nodeSprites.push(lbl);
        }

        // Custom Selection Plane (Shape Mode)
        const customPlane = new THREE.Mesh(new THREE.BufferGeometry(), new THREE.MeshBasicMaterial({ color: 0xfacc15, side: THREE.DoubleSide, transparent: true, opacity: 0.6 }));
        scene.add(customPlane);
        const customPlaneEdges = new THREE.LineSegments(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xca8a04, linewidth: 2 }));
        scene.add(customPlaneEdges);

        // --- Measurement Visualization Assets ---
        const measureGroup = new THREE.Group();
        scene.add(measureGroup);
        
        // Helper Lines for Measure Mode
        function createLineMesh(color, dashed=false) {
            const mat = dashed 
                ? new THREE.LineDashedMaterial({ color: color, dashSize: 0.2, gapSize: 0.1, linewidth: 2 }) 
                : new THREE.LineBasicMaterial({ color: color, linewidth: 3 });
            return new THREE.Line(new THREE.BufferGeometry(), mat);
        }
        const vizLine = createLineMesh(0x2563eb); // Blue for Selected Line
        const vizProj = createLineMesh(0x10b981, true); // Green Dashed for Projection
        const vizDrop1 = createLineMesh(0x9ca3af, true); // Drop line 1
        const vizDrop2 = createLineMesh(0x9ca3af, true); // Drop line 2
        measureGroup.add(vizLine, vizProj, vizDrop1, vizDrop2);

        // --- Thick Lines ---
        function createThickLine(color) {
            const mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1, 8), new THREE.MeshStandardMaterial({ color: color }));
            return mesh;
        }
        function updateThickLine(mesh, start, end) {
            const direction = new THREE.Vector3().subVectors(end, start);
            const len = direction.length();
            if (len < 0.001) { mesh.visible = false; return; }
            mesh.visible = true;
            mesh.position.copy(start).add(direction.clone().multiplyScalar(0.5));
            mesh.scale.set(1, len, 1);
            mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.clone().normalize());
        }

        const trueLine1 = createThickLine(0xef4444); plane1.add(trueLine1);
        const trueLine2 = createThickLine(0xef4444); plane2.add(trueLine2);
        const measureLine1 = createThickLine(0xd97706); plane1.add(measureLine1);
        const measureLine2 = createThickLine(0xd97706); plane2.add(measureLine2);
        const connectorLine = createThickLine(0x000000); scene.add(connectorLine);
        const rodLine = createThickLine(0x2563eb); scene.add(rodLine);

        // --- Angle Visualization ---
        const angleVizGroup = new THREE.Group();
        scene.add(angleVizGroup);
        const angleArc = new THREE.Mesh(new THREE.RingGeometry(1.2, 1.25, 32, 1, 0, 1), new THREE.MeshBasicMaterial({ color: 0x111827, side: THREE.DoubleSide }));
        angleVizGroup.add(angleArc);

        function createTextSprite(message, fontSize = 60, color = "#111827") {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 128;
            ctx.fillStyle = "rgba(0,0,0,0)"; ctx.fillRect(0,0,256,128);
            ctx.font = `Bold ${fontSize}px Arial`; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillStyle = color; ctx.fillText(message, 128, 64);
            const texture = new THREE.CanvasTexture(canvas);
            return new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, depthTest: false }));
        }
        let labelSprite = createTextSprite("45Â°", 80);
        angleVizGroup.add(labelSprite);
        let lengthLabel = createTextSprite("10", 60, "#b91c1c");
        scene.add(lengthLabel);

        // --- Slice Plane ---
        const slicePlane = new THREE.Mesh(new THREE.PlaneGeometry(6, 6), new THREE.MeshBasicMaterial({ color: 0xebf0ff, side: THREE.DoubleSide, transparent: true, opacity: 0.5 }));
        const sliceBorder = new THREE.LineSegments(new THREE.EdgesGeometry(slicePlane.geometry), new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
        slicePlane.add(sliceBorder);
        scene.add(slicePlane);

        // --- State ---
        const state = {
            mode: 'box', // Default changed from planes to box
            angle: 45, skew: 0, showSlice: false, shapeMode: 'rect-rect',
            lineOrientation: 'floor', lineDirection: 0,
            pyrWidth: 4, pyrHeight: 3,
            boxDims: { w: 4, h: 3, d: 3 }
        };

        // --- UI Updates ---
        const checkContainer = document.getElementById('node-checkboxes');
        
        function updateCheckboxes() {
            checkContainer.innerHTML = '';
            let activeLabels = nodeLabels; 
            if (state.mode === 'tri-prism') activeLabels = ['A', 'B', 'C', 'D', 'E', 'F']; 
            
            activeLabels.forEach(label => {
                const wrapper = document.createElement('label');
                wrapper.className = "flex items-center justify-center space-x-1 cursor-pointer bg-white p-2 rounded border border-gray-200 hover:bg-gray-50";
                
                const box = document.createElement('input');
                box.type = "checkbox";
                box.value = label;
                box.id = `check-node-${label}`;
                box.className = "form-checkbox h-4 w-4 text-blue-600 rounded focus:ring-blue-500 border-gray-300";
                
                const id = nodeMap[label];
                let isChecked = false;
                let isDisabled = false;

                if (measureState.active) {
                    if (measureState.step === 0) {
                        isChecked = measureState.line.includes(id);
                        if (!isChecked && measureState.line.length >= 2) isDisabled = true;
                    } else if (measureState.step === 1) {
                        isChecked = measureState.plane.includes(id);
                        // Allow up to 4 points
                        if (!isChecked && measureState.plane.length >= 4) isDisabled = true;
                    } else {
                        isDisabled = true;
                        isChecked = measureState.line.includes(id) || measureState.plane.includes(id);
                    }
                } else {
                    isChecked = selectedNodes.includes(id);
                    // Standard Shape Mode: Max 3
                    if (!isChecked && selectedNodes.length >= 3) isDisabled = true;
                }

                box.checked = isChecked;
                box.disabled = isDisabled;
                
                box.addEventListener('change', (e) => {
                    const id = nodeMap[label];
                    if (measureState.active) {
                        // Measure Mode Logic
                        if (measureState.step === 0) {
                            if (e.target.checked) measureState.line.push(id);
                            else measureState.line = measureState.line.filter(n => n !== id);
                            btnMeasureNext.disabled = measureState.line.length !== 2;
                        } else if (measureState.step === 1) {
                            if (e.target.checked) measureState.plane.push(id);
                            else measureState.plane = measureState.plane.filter(n => n !== id);
                            
                            // Enable button if 3 or 4 points selected
                            if (measureState.plane.length >= 3) {
                                btnMeasureNext.disabled = false;
                                btnMeasureNext.classList.remove('opacity-50', 'cursor-not-allowed');
                            } else {
                                btnMeasureNext.disabled = true;
                                btnMeasureNext.classList.add('opacity-50', 'cursor-not-allowed');
                            }
                        }
                    } else {
                        // Standard Mode Logic
                        if (e.target.checked) {
                             if(selectedNodes.length < 3) selectedNodes.push(id);
                        } else {
                            selectedNodes = selectedNodes.filter(n => n !== id);
                        }
                    }
                    updateCheckboxes();
                    updateSimulation();
                });

                const txt = document.createElement('span');
                txt.className = "text-xs font-bold text-gray-700";
                txt.textContent = label;

                wrapper.appendChild(box);
                wrapper.appendChild(txt);
                
                // Highlights
                if (measureState.active) {
                    if (measureState.line.includes(id)) wrapper.classList.add('ring-2', 'ring-blue-500', 'bg-blue-50');
                    if (measureState.plane.includes(id)) wrapper.classList.add('ring-2', 'ring-yellow-400', 'bg-yellow-50');
                } else {
                    if (selectedNodes.includes(id)) wrapper.classList.add("ring-2", "ring-yellow-400");
                }

                checkContainer.appendChild(wrapper);
            });
        }

        // --- Measure Mode UI Handlers ---
        btnFuncShape.onclick = () => {
            measureState.active = false;
            measureState.step = 0; measureState.line = []; measureState.plane = [];
            btnFuncShape.classList.replace('text-gray-500', 'text-blue-600');
            btnFuncShape.classList.replace('bg-white', 'bg-white'); // keep bg
            btnFuncShape.classList.add('shadow-sm');
            btnFuncMeasure.classList.replace('text-blue-600', 'text-gray-500');
            btnFuncMeasure.classList.remove('shadow-sm', 'bg-white');
            
            boxUiShape.style.display = 'block';
            boxUiMeasure.style.display = 'none';
            panelResults.style.display = 'none';
            selectedNodes = [];
            updateCheckboxes();
            updateSimulation();
        };

        btnFuncMeasure.onclick = () => {
            measureState.active = true;
            measureState.step = 0; measureState.line = []; measureState.plane = [];
            
            btnFuncMeasure.classList.replace('text-gray-500', 'text-blue-600');
            btnFuncMeasure.classList.add('shadow-sm', 'bg-white');
            btnFuncShape.classList.replace('text-blue-600', 'text-gray-500');
            btnFuncShape.classList.remove('shadow-sm', 'bg-white');

            boxUiShape.style.display = 'none';
            boxUiMeasure.style.display = 'block';
            measureInstruction.textContent = "Step 1: Select 2 points for the Line";
            measureInstruction.className = "text-xs text-blue-600 font-bold italic mb-2";
            btnMeasureNext.textContent = "Next: Select Plane";
            btnMeasureNext.disabled = true;
            
            updateCheckboxes();
            updateSimulation();
        };

        btnMeasureNext.onclick = () => {
            if (measureState.step === 0) {
                // Move to Plane Selection
                measureState.step = 1;
                measureInstruction.textContent = "Step 2: Select 3 or 4 points for the Plane";
                measureInstruction.className = "text-xs text-yellow-600 font-bold italic mb-2";
                btnMeasureNext.textContent = "Calculate Angle";
                btnMeasureNext.disabled = true;
                updateCheckboxes();
            } else if (measureState.step === 1) {
                // Perform Calculation
                measureState.step = 2;
                btnMeasureNext.disabled = true;
                updateSimulation();
            }
        };

        btnMeasureReset.onclick = () => {
            measureState.step = 0; measureState.line = []; measureState.plane = [];
            measureInstruction.textContent = "Step 1: Select 2 points for the Line";
            measureInstruction.className = "text-xs text-blue-600 font-bold italic mb-2";
            btnMeasureNext.textContent = "Next: Select Plane";
            btnMeasureNext.disabled = true;
            updateCheckboxes();
            updateSimulation();
        };

        // --- Update Function ---
        function updateSimulation() {
            // ... (Shared visibility cleanup)
            const hideAll = () => {
                plane1.visible = false; plane2.visible = false; spine.visible = false;
                trueLine1.visible = false; trueLine2.visible = false;
                measureLine1.visible = false; measureLine2.visible = false;
                connectorLine.visible = false; rodLine.visible = false;
                angleVizGroup.visible = false; scene.remove(lengthLabel);
                slicePlane.visible = false; boxEdgesMesh.visible = false;
                nodesGroup.visible = false; customPlane.visible = false; customPlaneEdges.visible = false;
                nodeSprites.forEach(s => s.visible = false);
                measureGroup.visible = false;
            };
            hideAll();

            if (state.mode === 'planes' || state.mode === 'line') {
                if(state.mode === 'planes') {
                    plane1.visible = true; plane2.visible = true; spine.visible = true;
                }
            } 
            
            if (state.mode === 'box' || state.mode === 'tri-prism') {
                boxEdgesMesh.visible = true;
                nodesGroup.visible = true;
                
                // Generate Corners
                const bw = state.boxDims.w, bh = state.boxDims.h, bd = state.boxDims.d;
                const halfW = bw/2;
                let corners = [];
                
                if (state.mode === 'box') {
                    const boxGeom = new THREE.BoxGeometry(bw, bh, bd);
                    const edgesGeom = new THREE.EdgesGeometry(boxGeom);
                    boxEdgesMesh.geometry.dispose(); boxEdgesMesh.geometry = edgesGeom;
                    boxEdgesMesh.position.set(0, bh/2, 0);
                    corners = [
                        new THREE.Vector3(halfW, bh, bd/2), new THREE.Vector3(halfW, bh, -bd/2),
                        new THREE.Vector3(-halfW, bh, -bd/2), new THREE.Vector3(-halfW, bh, bd/2),
                        new THREE.Vector3(halfW, 0, bd/2), new THREE.Vector3(halfW, 0, -bd/2),
                        new THREE.Vector3(-halfW, 0, -bd/2), new THREE.Vector3(-halfW, 0, bd/2)
                    ];
                } else {
                    // Right Tri Prism
                    corners[0] = new THREE.Vector3(-halfW, bh, -bd/2); // F
                    corners[3] = new THREE.Vector3(-halfW, bh, bd/2);  // E
                    corners[7] = new THREE.Vector3(-halfW, 0, bd/2);   // A
                    corners[4] = new THREE.Vector3(halfW, 0, bd/2);    // B
                    corners[5] = new THREE.Vector3(halfW, 0, -bd/2);   // C
                    corners[6] = new THREE.Vector3(-halfW, 0, -bd/2);  // D
                    corners[1] = new THREE.Vector3(0,-100,0); corners[2] = new THREE.Vector3(0,-100,0); // Unused

                    const lines = [
                        corners[7], corners[4], corners[4], corners[3], corners[3], corners[7],
                        corners[6], corners[5], corners[5], corners[0], corners[0], corners[6],
                        corners[3], corners[0], corners[7], corners[6], corners[4], corners[5]
                    ];
                    boxEdgesMesh.geometry.dispose();
                    boxEdgesMesh.geometry = new THREE.BufferGeometry().setFromPoints(lines);
                    boxEdgesMesh.position.set(0,0,0);
                }

                // Node Vis
                nodeMeshes.forEach((mesh, idx) => {
                    const sprite = nodeSprites[idx];
                    if (state.mode === 'tri-prism' && (idx === 1 || idx === 2)) {
                        mesh.visible = false; sprite.visible = false;
                    } else if (idx < 8) {
                        mesh.visible = true; mesh.position.copy(corners[idx]);
                        sprite.visible = true; 
                        const offset = corners[idx].clone().sub(new THREE.Vector3(0, bh/2, 0)).normalize().multiplyScalar(0.4);
                        if (corners[idx].y > 0) offset.y += 0.2;
                        sprite.position.copy(corners[idx]).add(offset);
                        
                        // Color Logic
                        let highlight = false;
                        if (measureState.active) {
                            if (measureState.line.includes(idx)) { mesh.material.color.setHex(0x2563eb); highlight=true; }
                            else if (measureState.plane.includes(idx)) { mesh.material.color.setHex(0xfacc15); highlight=true; }
                            else mesh.material.color.setHex(0x9ca3af);
                        } else {
                            if (selectedNodes.includes(idx)) { mesh.material.color.setHex(0xfacc15); highlight=true; }
                            else mesh.material.color.setHex(0x9ca3af);
                        }
                        mesh.scale.setScalar(highlight ? 1.5 : 1.0);
                    }
                });

                // --- SHAPE MODE LOGIC ---
                if (!measureState.active && selectedNodes.length === 3) {
                    customPlane.visible = true; customPlaneEdges.visible = true;
                    const p1 = corners[selectedNodes[0]], p2 = corners[selectedNodes[1]], p3 = corners[selectedNodes[2]];
                    const verts = [p1, p2, p3];
                    customPlane.geometry.dispose();
                    customPlane.geometry = new THREE.BufferGeometry().setFromPoints(verts);
                    customPlane.geometry.computeVertexNormals();
                    customPlaneEdges.geometry.dispose(); 
                    customPlaneEdges.geometry = new THREE.BufferGeometry().setFromPoints([p1, p2, p2, p3, p3, p1]);
                    
                    // 2D Draw
                    draw2DBoxTriangle(p1, p2, p3);
                }

                // --- MEASURE MODE LOGIC ---
                if (measureState.active) {
                    measureGroup.visible = true;
                    
                    // Reset colors (in case coming from step 2)
                    vizLine.material.color.setHex(0x2563eb); // Blue
                    vizProj.material.color.setHex(0x10b981); // Green
                    vizDrop1.material.color.setHex(0x9ca3af); // Gray
                    vizDrop2.material.color.setHex(0x9ca3af); // Gray

                    // 1. Draw Line
                    if (measureState.line.length === 2) {
                        const p1 = corners[measureState.line[0]];
                        const p2 = corners[measureState.line[1]];
                        vizLine.geometry.dispose();
                        vizLine.geometry = new THREE.BufferGeometry().setFromPoints([p1, p2]);
                        vizLine.visible = true;
                    } else { vizLine.visible = false; }

                    // 2. Draw Plane & Calculate (Only if calculated)
                    if (measureState.step === 2 && measureState.plane.length >= 3) {
                        
                        // Turn lines RED to mark the angle
                        vizLine.material.color.setHex(0xef4444);
                        vizProj.material.color.setHex(0xef4444);
                        vizDrop1.material.color.setHex(0xef4444);
                        vizDrop2.material.color.setHex(0xef4444);

                        // Gather points
                        const points = measureState.plane.map(idx => corners[idx]);
                        
                        // Determine Plane Type (3 or 4 points)
                        if (points.length === 3) {
                            // Triangle Plane
                            const pa = points[0], pb = points[1], pc = points[2];
                            customPlane.visible = true; 
                            customPlane.geometry.dispose();
                            customPlane.geometry = new THREE.BufferGeometry().setFromPoints([pa, pb, pc]);
                            customPlane.geometry.computeVertexNormals();
                            
                            customPlaneEdges.visible = true;
                            customPlaneEdges.geometry.dispose();
                            customPlaneEdges.geometry = new THREE.BufferGeometry().setFromPoints([pa, pb, pb, pc, pc, pa]);

                        } else if (points.length === 4) {
                            // Quad Plane logic
                            const center = points.reduce((acc, p) => acc.add(p), new THREE.Vector3()).multiplyScalar(0.25);
                            const vA = new THREE.Vector3().subVectors(points[1], points[0]);
                            const vB = new THREE.Vector3().subVectors(points[2], points[0]);
                            const tempNorm = new THREE.Vector3().crossVectors(vA, vB).normalize();
                            const refX = new THREE.Vector3().subVectors(points[0], center).normalize();
                            const refY = new THREE.Vector3().crossVectors(tempNorm, refX).normalize();
                            
                            points.sort((a, b) => {
                                const va = new THREE.Vector3().subVectors(a, center);
                                const vb = new THREE.Vector3().subVectors(b, center);
                                const angA = Math.atan2(va.dot(refY), va.dot(refX));
                                const angB = Math.atan2(vb.dot(refY), vb.dot(refX));
                                return angA - angB;
                            });

                            const pa = points[0], pb = points[1], pc = points[2], pd = points[3];
                            customPlane.visible = true; 
                            customPlane.geometry.dispose();
                            customPlane.geometry = new THREE.BufferGeometry().setFromPoints([pa, pb, pc, pa, pc, pd]);
                            customPlane.geometry.computeVertexNormals();
                            customPlaneEdges.visible = true;
                            customPlaneEdges.geometry.dispose();
                            customPlaneEdges.geometry = new THREE.BufferGeometry().setFromPoints([pa, pb, pb, pc, pc, pd, pd, pa]);
                        }

                        if (measureState.line.length === 2) {
                            const p1 = corners[measureState.line[0]];
                            const p2 = corners[measureState.line[1]];
                            const label1 = reverseNodeMap[measureState.line[0]];
                            const label2 = reverseNodeMap[measureState.line[1]];
                            
                            // Calculate Normal (using first 3 points approx)
                            const pa = points[0], pb = points[1], pc = points[2];
                            const v1 = new THREE.Vector3().subVectors(pb, pa);
                            const v2 = new THREE.Vector3().subVectors(pc, pa);
                            const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
                            
                            // Use centroid for projection reference
                            const center = points.reduce((acc, p) => acc.add(p), new THREE.Vector3()).multiplyScalar(1/points.length);

                            // Line Vector
                            const lineVec = new THREE.Vector3().subVectors(p2, p1).normalize();
                            
                            // Angle Calculation
                            const dot = Math.abs(normal.dot(lineVec));
                            const angleRad = Math.asin(Math.min(1, dot));
                            const angleDeg = (angleRad * 180 / Math.PI).toFixed(1);

                            // Project Points
                            const projP1 = p1.clone().sub(normal.clone().multiplyScalar(p1.clone().sub(center).dot(normal)));
                            const projP2 = p2.clone().sub(normal.clone().multiplyScalar(p2.clone().sub(center).dot(normal)));
                            
                            vizProj.geometry.dispose();
                            vizProj.geometry = new THREE.BufferGeometry().setFromPoints([projP1, projP2]);
                            vizProj.computeLineDistances(); 
                            vizProj.visible = true;

                            vizDrop1.geometry.dispose(); vizDrop1.geometry = new THREE.BufferGeometry().setFromPoints([p1, projP1]); vizDrop1.computeLineDistances();
                            vizDrop2.geometry.dispose(); vizDrop2.geometry = new THREE.BufferGeometry().setFromPoints([p2, projP2]); vizDrop2.computeLineDistances();
                            
                            // --- Determine Labels & Orientation for 2D ---
                            // Check which point of the line is closer to the plane (the angle vertex)
                            const d1 = Math.abs(normal.clone().dot(p1.clone().sub(center))); 
                            const d2 = Math.abs(normal.clone().dot(p2.clone().sub(center)));

                            let vAngle, vTop, lAngle, lTop, vProj, lProj;

                            if (d1 < d2) {
                                // p1 is on the plane
                                vAngle = p1; lAngle = label1;
                                vTop = p2; lTop = label2;
                            } else {
                                // p2 is on the plane
                                vAngle = p2; lAngle = label2;
                                vTop = p1; lTop = label1;
                            }

                            // Calculate projection of Top vertex (Right Angle Corner)
                            const distTop = vTop.clone().sub(center).dot(normal);
                            vProj = vTop.clone().sub(normal.clone().multiplyScalar(distTop));

                            // Find nearest node for Projection Label
                            lProj = lTop + "'"; // Default: B -> B'
                            let minDist = 999;
                            for(let i=0; i<corners.length; i++) {
                                const d = vProj.distanceTo(corners[i]);
                                if(d < 0.1 && d < minDist) {
                                    minDist = d;
                                    lProj = reverseNodeMap[i];
                                }
                            }

                            const angleName = `âˆ ${lTop}${lAngle}${lProj}`;

                            // UI Feedback
                            measureInstruction.textContent = `${angleName} = ?`;
                            measureInstruction.className = "text-sm text-green-600 font-bold bg-green-50 p-2 rounded text-center border border-green-200";
                            panelResults.style.display = 'block';
                            document.getElementById('display-measured-angle').textContent = "?"; // Hidden per request
                            document.getElementById('label-result-title').textContent = `${angleName}`;
                            document.getElementById('label-result-extra').textContent = "";
                            document.getElementById('display-line-length').textContent = "";
                            document.getElementById('status-message').textContent = "PROJECTION VISUALIZED";
                            document.getElementById('status-explanation').textContent = "The angle is measured between the line and its orthogonal projection onto the selected plane.";
                            
                            // 2D View
                            draw2DProjection(angleDeg, lAngle, lTop, lProj, angleName);
                        }
                    } else {
                        vizProj.visible = false; vizDrop1.visible = false; vizDrop2.visible = false;
                        if (measureState.active && measureState.step < 2) {
                             customPlane.visible = false;
                             customPlaneEdges.visible = false;
                        }
                    }
                }
            }
        }

        // --- 2D Helpers ---
        const ctx2d = document.getElementById('triangle-2d').getContext('2d');
        
        function draw2DBoxTriangle(p1, p2, p3) {
            ctx2d.clearRect(0,0,240,140);
            ctx2d.fillStyle = "#666"; ctx2d.textAlign="center";
            ctx2d.font = "italic 14px Arial";
            ctx2d.fillText("Shape View", 120, 70);
            ctx2d.font = "12px Arial";
            ctx2d.fillText("(Plane Selected)", 120, 90);
        }

        function draw2DProjection(angle, labelAngle, labelTop, labelProj, angleName) {
            const w = 240, h = 140;
            const ctx = ctx2d;
            ctx.clearRect(0,0,w,h);
            
            // Draw Right Triangle
            const mX = 50, mY = h-30;
            const scale = 140;
            const rad = angle * Math.PI/180;
            const baseLen = scale * Math.cos(rad);
            const heightLen = scale * Math.sin(rad);

            // Path
            ctx.beginPath();
            ctx.moveTo(mX, mY); // Start (Vertex)
            ctx.lineTo(mX + baseLen, mY); // Base end
            ctx.lineTo(mX + baseLen, mY - heightLen); // Top
            ctx.closePath();

            // Fill
            ctx.fillStyle = "rgba(239, 68, 68, 0.05)";
            ctx.fill();

            // Edges
            // 1. Base (Projection)
            ctx.beginPath();
            ctx.moveTo(mX, mY);
            ctx.lineTo(mX + baseLen, mY);
            ctx.strokeStyle = "#ef4444"; 
            ctx.lineWidth = 4;
            ctx.setLineDash([5, 3]);
            ctx.stroke();
            ctx.setLineDash([]);

            // 2. Height (Drop)
            ctx.beginPath();
            ctx.moveTo(mX + baseLen, mY);
            ctx.lineTo(mX + baseLen, mY - heightLen);
            ctx.strokeStyle = "#ef4444"; 
            ctx.lineWidth = 4;
            ctx.setLineDash([2, 2]);
            ctx.stroke();
            ctx.setLineDash([]);

            // 3. Hypotenuse (Line)
            ctx.beginPath();
            ctx.moveTo(mX, mY);
            ctx.lineTo(mX + baseLen, mY - heightLen);
            ctx.strokeStyle = "#ef4444"; 
            ctx.lineWidth = 4;
            ctx.stroke();

            // Right Angle Mark
            const raSize = 10;
            ctx.beginPath();
            ctx.moveTo(mX + baseLen - raSize, mY);
            ctx.lineTo(mX + baseLen - raSize, mY - raSize);
            ctx.lineTo(mX + baseLen, mY - raSize);
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            ctx.stroke();

            // Angle Arc
            const arcR = 30;
            ctx.beginPath();
            ctx.arc(mX, mY, arcR, 0, -rad, true);
            ctx.strokeStyle = "#000";
            ctx.stroke();

            // Labels
            ctx.fillStyle = "#000"; 
            ctx.textAlign = "center";
            ctx.font = "bold 16px Arial";
            
            // Angle Name
            ctx.fillText(angleName + " = ?", mX + 45, mY - 5);

            // Vertex Labels
            ctx.fillStyle = "#2563eb"; // Blue for nodes
            ctx.fillText(labelAngle, mX - 15, mY + 5); // Angle Node
            ctx.fillText(labelTop, mX + baseLen + 5, mY - heightLen - 10); // Top Node
            ctx.fillText(labelProj, mX + baseLen + 15, mY + 5); // Projection Node

            // Side Descriptions
            ctx.fillStyle = "#666"; 
            ctx.font = "11px Arial";
            
            ctx.fillText("Projection", mX + baseLen/2, mY + 20);
            
            ctx.save();
            ctx.translate(mX + baseLen + 30, mY - heightLen/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText("Height", 0, 0);
            ctx.restore();
            
            ctx.save();
            ctx.translate(mX + baseLen/2 - 10, mY - heightLen/2 - 10);
            ctx.rotate(-rad);
            ctx.fillText("Line", 0, 0);
            ctx.restore();
        }

        // --- Init ---
        function setMode(m) {
            state.mode = m;
            shapeControl.style.display = m === 'planes' ? 'block' : 'none';
            lineControl.style.display = m === 'line' ? 'block' : 'none';
            pyramidControl.style.display = m === 'pyramid' ? 'block' : 'none';
            boxControl.style.display = (m === 'box' || m === 'tri-prism') ? 'block' : 'none';
            mainAngleControl.style.display = (m === 'planes' || m === 'line') ? 'block' : 'none';
            
            // Mode switching resets
            measureState.active = false; 
            btnFuncShape.click(); // Default to shape view
            updateSimulation();
        }

        // --- Handlers ---
        btnPlanes.onclick = () => setMode('planes');
        btnLine.onclick = () => setMode('line');
        btnBox.onclick = () => setMode('box');
        btnTriPrism.onclick = () => setMode('tri-prism');
        // ... (Other standard handlers) ...
        document.getElementById('input-box-w').addEventListener('input', (e) => { state.boxDims.w = parseFloat(e.target.value); updateSimulation(); });
        document.getElementById('input-box-h').addEventListener('input', (e) => { state.boxDims.h = parseFloat(e.target.value); updateSimulation(); });
        document.getElementById('input-box-d').addEventListener('input', (e) => { state.boxDims.d = parseFloat(e.target.value); updateSimulation(); });

        setMode('box'); // Set default mode to box
        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
        animate();
    </script>
</body>
</html>
