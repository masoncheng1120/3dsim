<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Trigonometry Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f3f4f6; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        .panel {
            backdrop-filter: blur(10px);
            background-color: rgba(255, 255, 255, 0.95);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body>

    <!-- UI Overlay -->
    <div class="absolute top-4 left-4 z-10 w-80 panel rounded-xl p-6 border border-gray-200 overflow-y-auto max-h-[90vh]">
        <h1 class="text-xl font-bold text-gray-800 mb-4">3D Trigonometry</h1>

        <!-- Mode Selection -->
        <div class="mb-6">
            <label class="block text-xs font-bold text-gray-500 uppercase tracking-wide mb-2">Select Concept</label>
            <div class="flex bg-gray-100 p-1 rounded-lg">
                <button id="mode-planes" class="flex-1 py-1.5 px-3 rounded-md text-sm font-semibold bg-white shadow-sm text-gray-800 transition-all">Two Planes</button>
                <button id="mode-line" class="flex-1 py-1.5 px-3 rounded-md text-sm font-semibold text-gray-500 hover:text-gray-700 transition-all">Line & Plane</button>
            </div>
        </div>

        <!-- Controls -->
        <div class="space-y-6">

            <!-- Planes Mode Controls -->
            <div id="control-shapes">
                <label class="block text-sm font-semibold text-gray-700 mb-2">Plane Shapes</label>
                <div class="relative">
                    <select id="shape-select" class="block w-full px-3 py-2 text-sm text-gray-700 bg-gray-50 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 outline-none appearance-none">
                        <option value="rect-rect">Two Rectangles (Book)</option>
                        <option value="tri-rect">Triangle & Rectangle</option>
                        <option value="tri-tri">Two Triangles</option>
                        <option value="tri-irregular">Irregular Tri & Rectangle</option>
                    </select>
                    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700">
                        <svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                    </div>
                </div>
                <button id="btn-randomize" class="mt-2 w-full bg-blue-100 text-blue-700 px-3 py-1.5 rounded-md text-xs font-bold hover:bg-blue-200 transition-colors hidden">
                    ðŸŽ² Randomize Top Shape
                </button>
            </div>

            <!-- Line Mode Controls (Hidden by default) -->
            <div id="control-line-options" class="hidden">
                <label class="block text-sm font-semibold text-gray-700 mb-2">Plane Orientation</label>
                <div class="relative mb-4">
                    <select id="line-orientation" class="block w-full px-3 py-2 text-sm text-gray-700 bg-gray-50 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 outline-none appearance-none">
                        <option value="floor">Floor (Horizontal)</option>
                        <option value="wall">Wall (Vertical)</option>
                    </select>
                    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700">
                        <svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                    </div>
                </div>

                <label class="flex justify-between text-sm font-semibold text-gray-700 mb-1">
                    <span>Line Direction</span>
                    <span id="label-direction" class="text-blue-600">0Â°</span>
                </label>
                <input type="range" id="input-direction" min="0" max="360" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
            </div>
            
            <!-- Angle Control -->
            <div>
                <label class="flex justify-between text-sm font-semibold text-gray-700 mb-1">
                    <span id="label-angle-title">Opening Angle</span>
                    <span id="label-plane-angle" class="text-blue-600">45Â°</span>
                </label>
                <input type="range" id="input-plane-angle" min="10" max="85" value="45" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
            </div>

            <!-- Path/Skew Control -->
            <div>
                <label class="flex justify-between text-sm font-semibold text-gray-700 mb-1">
                    <span id="label-skew-title">Measurement Path</span>
                    <span id="label-skew" class="text-gray-500">Perpendicular</span>
                </label>
                <input type="range" id="input-skew" min="0" max="3" step="0.1" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-red-500">
                <p id="hint-skew" class="text-xs text-gray-500 mt-1">Slide right to measure diagonally.</p>
            </div>

            <!-- 2D Representation -->
            <div class="bg-gray-50 rounded-lg p-3 border border-gray-200">
                <label id="label-2d-title" class="block text-xs font-bold text-gray-600 mb-2 text-center">2D View</label>
                <canvas id="triangle-2d" width="240" height="140" class="mx-auto"></canvas>
            </div>

            <!-- Toggles -->
            <div class="flex items-center justify-between pt-2">
                <span class="text-sm font-medium text-gray-700">Show Slicing Plane</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggle-slice" class="sr-only peer">
                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                </label>
            </div>

        </div>

        <!-- Result Display -->
        <div class="mt-6 pt-6 border-t border-gray-200">
            <div class="flex justify-between items-end mb-2">
                <span class="text-sm text-gray-600">Measured Angle:</span>
                <span id="display-measured-angle" class="text-2xl font-bold text-green-600">45.0Â°</span>
            </div>
            <div class="flex justify-between items-end mb-2">
                <span id="label-result-extra" class="text-sm text-gray-600">Hypotenuse Length:</span>
                <span id="display-line-length" class="text-lg font-bold text-gray-800">10.0</span>
            </div>
            <div id="status-message" class="text-xs font-bold text-green-600 bg-green-100 p-2 rounded text-center">
                CORRECT: Shortest Distance
            </div>
            <p id="status-explanation" class="text-xs text-gray-500 mt-2 leading-relaxed">
                You are measuring along the perpendicular lines. This is the true definition of the angle.
            </p>
        </div>
    </div>

    <!-- Legend -->
    <div class="absolute bottom-4 right-4 z-10 panel rounded-lg p-4 text-xs space-y-2 border border-gray-200">
        <div id="legend-p1" class="flex items-center">
            <div class="w-3 h-3 bg-blue-400 mr-2 rounded-sm opacity-50"></div> <span>Plane 1 (Top)</span>
        </div>
        <div class="flex items-center">
            <div class="w-3 h-3 bg-green-400 mr-2 rounded-sm opacity-50"></div> <span id="legend-p2-text">Plane 2 (Ground)</span>
        </div>
        <div id="legend-spine" class="flex items-center">
            <div class="w-8 h-0.5 bg-black mr-2"></div> <span>Intersection (Spine)</span>
        </div>
        <div id="legend-true" class="flex items-center">
            <div class="w-8 h-1 bg-red-500 mr-2 rounded-full"></div> <span>True Angle Line</span>
        </div>
        <div id="legend-measure" class="flex items-center">
            <div class="w-8 h-1 bg-yellow-600 mr-2 rounded-full border border-yellow-700"></div> <span>Measured Line</span>
        </div>
        <div class="flex items-center mt-2">
             <div class="w-8 h-1 bg-black mr-2 rounded-full"></div> <span>Vertical Drop</span>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script>
        // --- Setup Three.js ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf3f4f6);
        scene.fog = new THREE.Fog(0xf3f4f6, 10, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 6, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- Helpers ---
        const gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xe5e7eb);
        scene.add(gridHelper);

        // --- Objects Container ---
        const bookGroup = new THREE.Group();
        scene.add(bookGroup);

        // --- Geometries & Materials ---
        const spineGeo = new THREE.CylinderGeometry(0.05, 0.05, 6, 16);
        const spineMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const spine = new THREE.Mesh(spineGeo, spineMat);
        spine.rotation.x = Math.PI / 2; 
        bookGroup.add(spine);

        const planeWidth = 4;
        const planeHeight = 4;
        
        // Standard Rect (Offset for Book)
        const rectGeo = new THREE.BufferGeometry();
        rectGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
            0, 0, -planeHeight/2, planeWidth, 0, -planeHeight/2, 
            0, 0, planeHeight/2,  planeWidth, 0, planeHeight/2  
        ]), 3));
        rectGeo.setIndex([0, 2, 1, 2, 3, 1]);
        rectGeo.computeVertexNormals();

        // Centered Rect (For Line/Plane mode)
        const groundGeo = new THREE.PlaneGeometry(10, 10);
        // PlaneGeometry is on XY by default? No, XY. We need XZ for floor.
        // But we rotate it. Let's keep standard PlaneGeometry (which is XY aligned) 
        // and rotate it to Horizontal (XZ) or Vertical (XY) as needed.
        // Actually, PlaneGeometry is X-Y. We usually rotate -90 X to make it floor.

        // Standard Tri
        const triGeo = new THREE.BufferGeometry();
        triGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
            0, 0, -planeHeight/2, 0, 0, planeHeight/2, planeWidth, 0, 0
        ]), 3));
        triGeo.setIndex([0, 1, 2]);
        triGeo.computeVertexNormals();

        function createIrregularTriGeometry(width, tipZOffset) {
            const g = new THREE.BufferGeometry();
            g.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
                0, 0, -planeHeight/2, 0, 0, planeHeight/2, width, 0, tipZOffset
            ]), 3));
            g.setIndex([0, 1, 2]);
            g.computeVertexNormals();
            return g;
        }

        const matPlane1 = new THREE.MeshStandardMaterial({ color: 0x60a5fa, side: THREE.DoubleSide, transparent: true, opacity: 0.8, roughness: 0.1 });
        const matPlane2 = new THREE.MeshStandardMaterial({ color: 0x4ade80, side: THREE.DoubleSide, transparent: true, opacity: 0.8, roughness: 0.1 });

        const plane1 = new THREE.Mesh(rectGeo, matPlane1);
        const plane2 = new THREE.Mesh(rectGeo, matPlane2);
        bookGroup.add(plane1);
        bookGroup.add(plane2);

        // --- Thick Lines (Cylinders) ---
        function createThickLine(color) {
            const geometry = new THREE.CylinderGeometry(0.04, 0.04, 1, 8);
            const material = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            return mesh;
        }

        function updateThickLine(mesh, start, end) {
            const direction = new THREE.Vector3().subVectors(end, start);
            const length = direction.length();
            if (length < 0.001) { mesh.visible = false; return; }
            mesh.visible = true;
            mesh.position.copy(start).add(direction.clone().multiplyScalar(0.5));
            mesh.scale.set(1, length, 1);
            const axis = new THREE.Vector3(0, 1, 0); 
            mesh.quaternion.setFromUnitVectors(axis, direction.clone().normalize());
        }

        const trueLine1 = createThickLine(0xef4444); // Top Red
        const trueLine2 = createThickLine(0xef4444); // Bottom Red (Shadow)
        plane1.add(trueLine1);
        plane2.add(trueLine2);

        const measureLine1 = createThickLine(0xd97706); // Top Yellow
        const measureLine2 = createThickLine(0xd97706); // Bottom Yellow
        plane1.add(measureLine1);
        plane2.add(measureLine2);

        const connectorLine = createThickLine(0x000000); // Black Vertical
        scene.add(connectorLine);

        // --- Rod for Line/Plane Mode ---
        const rodLine = createThickLine(0x2563eb); // Blue Rod
        rodLine.visible = false;
        scene.add(rodLine);

        // --- Visualization Assets ---
        const angleVizGroup = new THREE.Group();
        scene.add(angleVizGroup);

        const arcGeo = new THREE.RingGeometry(1.2, 1.25, 32, 1, 0, 1);
        const arcMat = new THREE.MeshBasicMaterial({ color: 0x111827, side: THREE.DoubleSide });
        const angleArc = new THREE.Mesh(arcGeo, arcMat);
        angleVizGroup.add(angleArc);

        function createTextSprite(message, fontSize = 60, color = "#111827") {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 128;
            ctx.fillStyle = "rgba(0,0,0,0)"; ctx.fillRect(0,0,256,128);
            ctx.font = `Bold ${fontSize}px Arial`; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillStyle = color; ctx.fillText(message, 128, 64);
            const texture = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, depthTest: false }));
            return sprite;
        }

        let labelSprite = createTextSprite("45Â°", 80);
        labelSprite.scale.set(1.5, 0.75, 1);
        angleVizGroup.add(labelSprite);

        let lengthLabel = createTextSprite("10", 60, "#b91c1c");
        lengthLabel.scale.set(1.5, 0.75, 1);
        scene.add(lengthLabel);

        const slicePlane = new THREE.Mesh(new THREE.PlaneGeometry(6, 6), new THREE.MeshStandardMaterial({ color: 0xa855f7, side: THREE.DoubleSide, transparent: true, opacity: 0.2 }));
        slicePlane.visible = false;
        scene.add(slicePlane);

        // --- State ---
        const state = {
            mode: 'planes', 
            angle: 45,
            skew: 0,
            showSlice: false,
            shapeMode: 'rect-rect',
            irregularParams: { p1Width: 4, p1TipZ: 1.5 },
            lineOrientation: 'floor', // 'floor' or 'wall'
            lineDirection: 0 // Degrees 0-360
        };

        // --- 2D Drawing ---
        const ctx2d = document.getElementById('triangle-2d').getContext('2d');

        // --- Update Function ---
        function updateSimulation() {
            const angleRad = state.angle * Math.PI / 180;
            const lift = 0.02;

            if (state.mode === 'planes') {
                // === PLANES MODE LOGIC ===
                
                rodLine.visible = false;
                plane1.visible = true;
                plane2.visible = true;
                spine.visible = true;
                
                if (state.shapeMode.startsWith('tri-irregular')) {
                    if (plane1.geometry !== rectGeo && plane1.geometry !== triGeo) plane1.geometry.dispose();
                    plane1.geometry = createIrregularTriGeometry(state.irregularParams.p1Width, state.irregularParams.p1TipZ);
                    plane2.geometry = rectGeo;
                    var currentBaseZ = state.irregularParams.p1TipZ;
                    var currentLen = state.irregularParams.p1Width;
                } else {
                    plane1.geometry = (state.shapeMode === 'rect-rect') ? rectGeo : triGeo;
                    plane2.geometry = (state.shapeMode === 'tri-tri') ? triGeo : rectGeo;
                    var currentBaseZ = 0;
                    var currentLen = 3;
                }

                plane2.rotation.set(0,0,0);
                plane1.rotation.set(0,0, angleRad);

                const zOffset = state.skew * 2;
                
                // True Lines (Red)
                const t1Start = new THREE.Vector3(0, lift, currentBaseZ);
                const t1End = new THREE.Vector3(currentLen, lift, currentBaseZ);
                updateThickLine(trueLine1, t1Start, t1End);
                
                const tTipWorld = t1End.clone().applyMatrix4(plane1.matrixWorld);
                const tDropWorld = new THREE.Vector3(tTipWorld.x, 0, tTipWorld.z);
                const t2Start = new THREE.Vector3(0, lift, currentBaseZ); 
                const t2End = new THREE.Vector3(tDropWorld.x, lift, tDropWorld.z); 
                updateThickLine(trueLine2, t2Start, t2End);

                // Measure Lines (Yellow) - Skewed on plane
                const m1Start = new THREE.Vector3(0, lift, currentBaseZ);
                const m1End = new THREE.Vector3(currentLen, lift, currentBaseZ + zOffset);
                updateThickLine(measureLine1, m1Start, m1End);

                const mTipWorld = m1End.clone().applyMatrix4(plane1.matrixWorld);
                const mDropWorld = new THREE.Vector3(mTipWorld.x, 0, mTipWorld.z);

                const m2Start = new THREE.Vector3(0, lift, currentBaseZ);
                const m2End = new THREE.Vector3(mDropWorld.x, lift, mDropWorld.z);
                updateThickLine(measureLine2, m2Start, m2End);

                // Connector
                updateThickLine(connectorLine, mTipWorld, mDropWorld);

                const hypotenuseLen = m1Start.distanceTo(m1End);
                const displayLen = ((hypotenuseLen / currentLen) * 10).toFixed(1);
                const height = mTipWorld.y;
                const base = Math.sqrt(mDropWorld.x*mDropWorld.x + zOffset*zOffset); 
                const measuredRad = Math.atan2(height, base);
                const measuredDeg = (measuredRad * 180 / Math.PI).toFixed(1);

                updateLabels(m1Start.clone().applyMatrix4(plane1.matrixWorld), mTipWorld, displayLen, measuredDeg, state.skew < 0.1);
                draw2DPlaneView(state.angle, measuredDeg, displayLen, state.skew > 0.1);

                const sliceAngle = Math.atan2(zOffset, mDropWorld.x);
                updateSlice(mDropWorld.x/2, 1, currentBaseZ + zOffset/2, 0, -sliceAngle, 0, measuredRad, measuredDeg, currentBaseZ);

            } else {
                // === LINE & PLANE MODE LOGIC ===
                
                rodLine.visible = true;
                plane1.visible = false; 
                plane2.visible = true; 
                spine.visible = false; 
                trueLine1.visible = false; 
                measureLine1.visible = false; 
                
                // Use large centered ground geometry
                plane2.geometry = groundGeo;

                const L = 4;
                const dirRad = state.lineDirection * Math.PI / 180;
                
                let rodVec, shadowVec;
                
                // --- WORLD SPACE CALCULATIONS ---
                if (state.lineOrientation === 'wall') {
                    // WALL: Vertical (XY Plane)
                    plane2.rotation.set(0, 0, Math.PI/2); // Rot Z+90 makes X go to Y, Y go to -X? 
                    // Let's stick to standard ThreeJS plane is XY.
                    // If we want it "Vertical", just rotate X -90? No, that's floor.
                    // Standard PlaneGeometry is XY.
                    // To make it face +Z (Wall), just position it. No rotation needed if default is XY.
                    plane2.rotation.set(0, 0, 0); 
                    
                    // Rod definition:
                    // Z is "out".
                    const z = L * Math.sin(angleRad);
                    const r_proj = L * Math.cos(angleRad);
                    const x = r_proj * Math.cos(dirRad);
                    const y = r_proj * Math.sin(dirRad);
                    
                    rodVec = new THREE.Vector3(x, y, z);
                    shadowVec = new THREE.Vector3(x, y, 0); 
                    
                } else {
                    // FLOOR: Horizontal (XZ Plane)
                    plane2.rotation.set(-Math.PI/2, 0, 0); // Rot X -90 makes XY -> XZ
                    
                    // Rod definition:
                    // Y is "up".
                    const y = L * Math.sin(angleRad);
                    const r_proj = L * Math.cos(angleRad);
                    const x = r_proj * Math.cos(dirRad);
                    const z = r_proj * Math.sin(dirRad);
                    
                    rodVec = new THREE.Vector3(x, y, z);
                    shadowVec = new THREE.Vector3(x, 0, z);
                }

                // Update Rod (Scene Object)
                updateThickLine(rodLine, new THREE.Vector3(0,0,0), rodVec);

                // --- PROJECTION & TEST LINES (Attached to Plane2) ---
                // Must convert World Space coordinates to Plane2 Local Space
                // Important: Update matrix before conversion
                plane2.updateMatrixWorld();
                
                const originLocal = new THREE.Vector3(0,0,0); // Origin is shared
                // Convert tips to local
                const shadowTipLocal = plane2.worldToLocal(shadowVec.clone());
                
                // Lift slightly in Local Z (which is normal to plane surface)
                originLocal.z += lift;
                shadowTipLocal.z += lift;
                
                // Draw Projection (Red)
                updateThickLine(trueLine2, originLocal, shadowTipLocal); 

                // Draw Test Line (Yellow)
                // World Space rotation calculation
                const devAngle = state.skew * 20 * Math.PI / 180; 
                // Rotate shadowVec around plane Normal
                const normal = (state.lineOrientation === 'wall') ? new THREE.Vector3(0,0,1) : new THREE.Vector3(0,1,0);
                const testVecWorld = shadowVec.clone().applyAxisAngle(normal, devAngle);
                
                if (testVecWorld.length() < 0.01) testVecWorld.set(0.1, 0, 0); // Avoid degenerate

                // Convert to Local
                const testTipLocal = plane2.worldToLocal(testVecWorld.clone());
                testTipLocal.z += lift;
                
                updateThickLine(measureLine2, originLocal, testTipLocal);

                // Connector (Drop) - Scene Object
                updateThickLine(connectorLine, rodVec, shadowVec);
                
                // --- Angle Calculation ---
                const v1 = rodVec.clone().normalize();
                const v2 = testVecWorld.clone().normalize();
                const dot = v1.dot(v2);
                const calcRad = Math.acos(Math.min(1, Math.max(-1, dot)));
                const calcDeg = (calcRad * 180 / Math.PI).toFixed(1);

                // Update UI Text
                updateLabels(new THREE.Vector3(0,0,0), rodVec, "10.0", calcDeg, state.skew < 0.1);

                draw2DLineMode(state.angle, calcDeg, state.skew > 0.1);

                // Slice/Arc Orientation
                const planeNorm = new THREE.Vector3().crossVectors(v2, v1).normalize();
                if (planeNorm.lengthSq() < 0.001) planeNorm.set(1,0,0); 
                
                const gx = v2.clone(); // X axis along test line
                const gz = planeNorm.clone(); // Z axis along normal
                const gy = new THREE.Vector3().crossVectors(gz, gx).normalize();
                const m = new THREE.Matrix4().makeBasis(gx, gy, gz);
                
                angleVizGroup.position.set(0,0,0);
                angleVizGroup.setRotationFromMatrix(m);
                
                const arcRadius = 1.5;
                angleArc.geometry.dispose();
                angleArc.geometry = new THREE.RingGeometry(arcRadius, arcRadius + 0.05, 32, 1, 0, calcRad);
                
                angleVizGroup.remove(labelSprite);
                labelSprite = createTextSprite(`${calcDeg}Â°`);
                const lx = (arcRadius + 0.6) * Math.cos(calcRad/2);
                const ly = (arcRadius + 0.6) * Math.sin(calcRad/2);
                labelSprite.position.set(lx, ly, 0);
                angleVizGroup.add(labelSprite);
                
                slicePlane.visible = false;
            }
        }

        // --- View Helpers ---

        function updateLabels(start, end, lenStr, angStr, isCorrect) {
            document.getElementById('display-line-length').textContent = lenStr;
            document.getElementById('display-measured-angle').textContent = `${angStr}Â°`;
            const labelPos = start.clone().add(end).multiplyScalar(0.5);
            labelPos.y += 0.4;
            if (state.mode === 'line' && state.lineOrientation === 'wall') labelPos.z += 0.4; 
            
            lengthLabel.position.copy(labelPos);
            
            scene.remove(lengthLabel);
            const col = isCorrect ? "#059669" : "#dc2626";
            lengthLabel = createTextSprite(lenStr, 60, col);
            lengthLabel.scale.set(1.5, 0.75, 1);
            lengthLabel.position.copy(labelPos);
            scene.add(lengthLabel);

            const msg = document.getElementById('status-message');
            const expl = document.getElementById('status-explanation');
            
            if (state.mode === 'planes') {
                if (isCorrect) {
                    msg.className = "text-xs font-bold text-green-700 bg-green-100 p-2 rounded text-center";
                    msg.textContent = "CORRECT: Perpendicular";
                    expl.textContent = "You are measuring perpendicular to the intersection. Shortest distance = Correct Angle.";
                } else {
                    msg.className = "text-xs font-bold text-red-700 bg-red-100 p-2 rounded text-center";
                    msg.textContent = "DISTORTED: Longer Path";
                    expl.textContent = `The measurement line is longer (${lenStr}). Because the height is constant, a longer hypotenuse means a SMALLER angle.`;
                }
            } else {
                if (isCorrect) {
                    msg.className = "text-xs font-bold text-green-700 bg-green-100 p-2 rounded text-center";
                    msg.textContent = "CORRECT: Projection";
                    expl.textContent = "The angle between a line and plane is defined by its projection. This is the minimum possible angle.";
                } else {
                    msg.className = "text-xs font-bold text-red-700 bg-red-100 p-2 rounded text-center";
                    msg.textContent = "DISTORTED: Deviation";
                    expl.textContent = `You are measuring against a line rotated away from the projection. This effectively makes the angle LARGER than the true inclination.`;
                }
            }
        }

        function updateSlice(px, py, pz, rx, ry, rz, arcLen, arcDeg, zBase) {
            slicePlane.rotation.set(Math.PI/2, ry, 0); 
            slicePlane.position.set(px, py, pz);
            slicePlane.visible = state.showSlice;

            angleVizGroup.position.set(0, 0, zBase);
            angleVizGroup.rotation.set(rx, ry, rz);

            const r = 1.5;
            angleArc.geometry.dispose();
            angleArc.geometry = new THREE.RingGeometry(r, r + 0.05, 32, 1, 0, arcLen);

            angleVizGroup.remove(labelSprite);
            labelSprite = createTextSprite(`${arcDeg}Â°`);
            labelSprite.position.set((r+0.6)*Math.cos(arcLen/2), (r+0.6)*Math.sin(arcLen/2), 0);
            angleVizGroup.add(labelSprite);
        }

        function draw2DPlaneView(trueAng, measAng, len, isSkew) {
            const w = ctx2d.canvas.width; const h = ctx2d.canvas.height;
            ctx2d.clearRect(0, 0, w, h);
            const startX = 40; const startY = h - 20; const scale = 120;
            const angRad = trueAng * Math.PI / 180; 
            
            const height = scale * Math.sin(angRad); 
            const trueBase = scale * Math.cos(angRad); 
            const valLen = parseFloat(len);
            const ratio = valLen / 10;
            const measHyp = scale * ratio; 
            const measBase = Math.sqrt(Math.max(0, measHyp*measHyp - height*height));

            const maxBase = Math.max(trueBase, measBase);
            ctx2d.beginPath(); ctx2d.moveTo(startX, startY); ctx2d.lineTo(startX + maxBase + 20, startY);
            ctx2d.strokeStyle = "#4ade80"; ctx2d.lineWidth=3; ctx2d.stroke();

            ctx2d.beginPath(); ctx2d.moveTo(startX, startY); ctx2d.lineTo(startX + trueBase, startY - height); 
            ctx2d.strokeStyle = "rgba(239, 68, 68, 0.3)"; ctx2d.lineWidth=4; ctx2d.stroke();
            
            ctx2d.beginPath(); ctx2d.moveTo(startX + trueBase, startY); ctx2d.lineTo(startX + trueBase, startY - height);
            ctx2d.strokeStyle = "rgba(0, 0, 0, 0.1)"; ctx2d.lineWidth=2; ctx2d.stroke();

            ctx2d.beginPath(); ctx2d.moveTo(startX + measBase, startY); ctx2d.lineTo(startX + measBase, startY - height);
            ctx2d.strokeStyle = "#000"; ctx2d.lineWidth=3; ctx2d.stroke();

            ctx2d.beginPath(); ctx2d.moveTo(startX, startY); ctx2d.lineTo(startX + measBase, startY - height);
            ctx2d.strokeStyle = isSkew ? "#d97706" : "#ef4444"; ctx2d.lineWidth=4; ctx2d.stroke();
            
            ctx2d.fillStyle = "#000"; ctx2d.font="bold 14px Arial"; ctx2d.fillText(`${measAng}Â°`, startX+40, startY-10);
            ctx2d.font="12px Arial"; ctx2d.fillText("Height", startX + measBase + 5, startY - height/2);
            
            if(isSkew) {
                ctx2d.fillStyle = "#ef4444"; ctx2d.fillText("True", startX + trueBase/2 - 10, startY - height/2);
                ctx2d.fillStyle = "#d97706"; ctx2d.fillText("Measured", startX + measBase/2 + 10, startY - height - 5);
            }
        }

        function draw2DLineMode(trueAng, measAng, isSkew) {
            const w = ctx2d.canvas.width; const h = ctx2d.canvas.height;
            ctx2d.clearRect(0, 0, w, h);
            const cx = w/2; const cy = h - 20; const len = 100;
            
            const rad1 = trueAng * Math.PI / 180;
            const x1 = cx + len * Math.cos(rad1); const y1 = cy - len * Math.sin(rad1);
            
            const rad2 = measAng * Math.PI / 180; 
            const x2 = cx + len * Math.cos(rad2); const y2 = cy - len * Math.sin(rad2);

            ctx2d.beginPath(); ctx2d.moveTo(cx-20, cy); ctx2d.lineTo(cx+120, cy); ctx2d.strokeStyle="#4ade80"; ctx2d.stroke();

            ctx2d.beginPath(); ctx2d.moveTo(cx, cy); ctx2d.lineTo(x1, y1);
            ctx2d.strokeStyle = isSkew ? "rgba(239,68,68,0.3)" : "#ef4444"; ctx2d.lineWidth=4; ctx2d.stroke();

            if (isSkew) {
                ctx2d.beginPath(); ctx2d.moveTo(cx, cy); ctx2d.lineTo(x2, y2);
                ctx2d.strokeStyle = "#d97706"; ctx2d.lineWidth=4; ctx2d.stroke();
                ctx2d.fillStyle = "#d97706"; ctx2d.fillText(`${measAng}Â°`, x2+5, y2);
            } else {
                ctx2d.fillStyle = "#ef4444"; ctx2d.fillText(`${trueAng}Â°`, x1+5, y1);
            }
            
            ctx2d.fillStyle = "#000"; ctx2d.fillText(isSkew ? "Angle Increases" : "True Inclination", 10, 20);
        }

        // --- Logic Hooks ---
        const btnPlanes = document.getElementById('mode-planes');
        const btnLine = document.getElementById('mode-line');
        const shapeControl = document.getElementById('control-shapes');
        const lineControl = document.getElementById('control-line-options');
        const lblSkew = document.getElementById('label-skew-title');
        const hintSkew = document.getElementById('hint-skew');
        const lbl2d = document.getElementById('label-2d-title');
        const lblAngle = document.getElementById('label-angle-title');
        const lblExtra = document.getElementById('label-result-extra');

        function setMode(m) {
            state.mode = m;
            state.skew = 0; document.getElementById('input-skew').value = 0;
            state.angle = 45; document.getElementById('input-plane-angle').value = 45;
            document.getElementById('label-plane-angle').textContent = "45Â°";

            if (m === 'planes') {
                btnPlanes.className = "flex-1 py-1.5 px-3 rounded-md text-sm font-semibold bg-white shadow-sm text-gray-800 transition-all";
                btnLine.className = "flex-1 py-1.5 px-3 rounded-md text-sm font-semibold text-gray-500 hover:text-gray-700 transition-all";
                shapeControl.style.display = 'block';
                lineControl.style.display = 'none';
                lblSkew.textContent = "Measurement Path";
                hintSkew.textContent = "Slide right to measure diagonally.";
                lbl2d.textContent = "2D View: Vertical Section";
                lblAngle.textContent = "Opening Angle";
                lblExtra.textContent = "Hypotenuse Length:";
                // Show legend elements
                document.getElementById('legend-p1').style.display = 'flex';
                document.getElementById('legend-spine').style.display = 'flex';
                document.getElementById('legend-p2-text').textContent = "Plane 2 (Ground)";
                document.getElementById('legend-true').querySelector('span').textContent = "True Angle Line";
            } else {
                btnLine.className = "flex-1 py-1.5 px-3 rounded-md text-sm font-semibold bg-white shadow-sm text-gray-800 transition-all";
                btnPlanes.className = "flex-1 py-1.5 px-3 rounded-md text-sm font-semibold text-gray-500 hover:text-gray-700 transition-all";
                shapeControl.style.display = 'none';
                lineControl.style.display = 'block';
                lblSkew.textContent = "Deviation from Projection";
                hintSkew.textContent = "Slide right to rotate away from projection.";
                lbl2d.textContent = "2D View: Side Comparison";
                lblAngle.textContent = "Line Inclination";
                lblExtra.textContent = "Fixed Length:";
                // Hide/Rename legend
                document.getElementById('legend-p1').style.display = 'none';
                document.getElementById('legend-spine').style.display = 'none';
                document.getElementById('legend-true').querySelector('span').textContent = "Projection";
                updateLegendForOrientation();
            }
            updateSimulation();
        }

        function updateLegendForOrientation() {
            const txt = state.lineOrientation === 'wall' ? "Vertical Wall" : "Horizontal Ground";
            document.getElementById('legend-p2-text').textContent = txt;
        }

        btnPlanes.onclick = () => setMode('planes');
        btnLine.onclick = () => setMode('line');

        document.getElementById('input-plane-angle').addEventListener('input', (e) => {
            state.angle = parseInt(e.target.value);
            document.getElementById('label-plane-angle').textContent = `${state.angle}Â°`;
            updateSimulation();
        });

        document.getElementById('input-skew').addEventListener('input', (e) => {
            state.skew = parseFloat(e.target.value);
            updateSimulation();
        });
        
        document.getElementById('line-orientation').addEventListener('change', (e) => {
            state.lineOrientation = e.target.value;
            updateLegendForOrientation();
            updateSimulation();
        });

        document.getElementById('input-direction').addEventListener('input', (e) => {
            state.lineDirection = parseInt(e.target.value);
            document.getElementById('label-direction').textContent = `${state.lineDirection}Â°`;
            updateSimulation();
        });

        document.getElementById('toggle-slice').addEventListener('change', (e) => {
            state.showSlice = e.target.checked;
            updateSimulation();
        });

        document.getElementById('shape-select').addEventListener('change', (e) => {
            state.shapeMode = e.target.value;
            updateSimulation();
        });
        
        document.getElementById('btn-randomize').addEventListener('click', () => {
             state.irregularParams.p1Width = 3.5 + Math.random() * 1.5;
             state.irregularParams.p1TipZ = (Math.random() - 0.5) * 4;
             updateSimulation();
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        setMode('planes');
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
