<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Trigonometry: Angle Between Planes</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f3f4f6; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        .panel {
            backdrop-filter: blur(10px);
            background-color: rgba(255, 255, 255, 0.95);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body>

    <!-- UI Overlay -->
    <div class="absolute top-4 left-4 z-10 w-80 panel rounded-xl p-6 border border-gray-200 overflow-y-auto max-h-[90vh]">
        <h1 class="text-xl font-bold text-gray-800 mb-1">Angles Between Planes</h1>
        <p class="text-xs text-gray-500 mb-4">Grade 11 Trigonometry Visualization</p>

        <!-- Controls -->
        <div class="space-y-6">

            <!-- Shape Selection -->
            <div>
                <label class="block text-sm font-semibold text-gray-700 mb-2">Plane Shapes</label>
                <div class="relative">
                    <select id="shape-select" class="block w-full px-3 py-2 text-sm text-gray-700 bg-gray-50 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 outline-none appearance-none">
                        <option value="rect-rect">Two Rectangles (Book)</option>
                        <option value="tri-rect">Triangle & Rectangle</option>
                        <option value="tri-tri">Two Triangles</option>
                        <option value="tri-irregular">Irregular Tri & Rectangle</option>
                    </select>
                    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700">
                        <svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                    </div>
                </div>
                <!-- Randomize Button (Hidden by default) -->
                <button id="btn-randomize" class="mt-2 w-full bg-blue-100 text-blue-700 px-3 py-1.5 rounded-md text-xs font-bold hover:bg-blue-200 transition-colors hidden">
                    ðŸŽ² Randomize Top Shape
                </button>
            </div>
            
            <!-- Plane Angle Control -->
            <div>
                <label class="flex justify-between text-sm font-semibold text-gray-700 mb-1">
                    <span>Opening Angle</span>
                    <span id="label-plane-angle" class="text-blue-600">60Â°</span>
                </label>
                <input type="range" id="input-plane-angle" min="10" max="90" value="45" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
            </div>

            <!-- Path Skew Control -->
            <div>
                <label class="flex justify-between text-sm font-semibold text-gray-700 mb-1">
                    <span>Measurement Path</span>
                    <span id="label-skew" class="text-gray-500">Perpendicular</span>
                </label>
                <input type="range" id="input-skew" min="0" max="3" step="0.1" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-red-500">
                <p class="text-xs text-gray-500 mt-1">Slide right to measure diagonally.</p>
            </div>

            <!-- 2D Representation -->
            <div class="bg-gray-50 rounded-lg p-3 border border-gray-200">
                <label class="block text-xs font-bold text-gray-600 mb-2 text-center">2D View: Vertical Section</label>
                <canvas id="triangle-2d" width="240" height="140" class="mx-auto"></canvas>
            </div>

            <!-- Toggles -->
            <div class="flex items-center justify-between pt-2">
                <span class="text-sm font-medium text-gray-700">Show Slicing Plane</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggle-slice" class="sr-only peer">
                    <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                </label>
            </div>

        </div>

        <!-- Result Display -->
        <div class="mt-6 pt-6 border-t border-gray-200">
            <div class="flex justify-between items-end mb-2">
                <span class="text-sm text-gray-600">Measured Angle:</span>
                <span id="display-measured-angle" class="text-2xl font-bold text-green-600">60.0Â°</span>
            </div>
            <div class="flex justify-between items-end mb-2">
                <span class="text-sm text-gray-600">Hypotenuse Length:</span>
                <span id="display-line-length" class="text-lg font-bold text-gray-800">10.0</span>
            </div>
            <div id="status-message" class="text-xs font-bold text-green-600 bg-green-100 p-2 rounded text-center">
                CORRECT: Shortest Distance
            </div>
            <p id="status-explanation" class="text-xs text-gray-500 mt-2 leading-relaxed">
                You are measuring along the perpendicular lines. This is the true definition of the angle.
            </p>
        </div>
    </div>

    <!-- Legend -->
    <div class="absolute bottom-4 right-4 z-10 panel rounded-lg p-4 text-xs space-y-2 border border-gray-200">
        <div class="flex items-center">
            <div class="w-3 h-3 bg-blue-400 mr-2 rounded-sm opacity-50"></div> <span>Plane 1 (Top)</span>
        </div>
        <div class="flex items-center">
            <div class="w-3 h-3 bg-green-400 mr-2 rounded-sm opacity-50"></div> <span>Plane 2 (Ground)</span>
        </div>
        <div class="flex items-center">
            <div class="w-8 h-0.5 bg-black mr-2"></div> <span>Intersection (Spine)</span>
        </div>
        <div class="flex items-center">
            <div class="w-8 h-1 bg-red-500 mr-2 rounded-full"></div> <span>True Angle Line</span>
        </div>
        <div class="flex items-center">
            <div class="w-8 h-1 bg-yellow-600 mr-2 rounded-full border border-yellow-700"></div> <span>Measured Line</span>
        </div>
        <div class="flex items-center mt-2">
             <div class="w-8 h-1 bg-black mr-2 rounded-full"></div> <span>Height (Perpendicular)</span>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script>
        // --- Setup Three.js ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf3f4f6);
        scene.fog = new THREE.Fog(0xf3f4f6, 10, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 6, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // --- Helpers ---
        const gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xe5e7eb);
        scene.add(gridHelper);

        // --- Objects Container ---
        const bookGroup = new THREE.Group();
        scene.add(bookGroup);

        // 1. Spine
        const spineGeo = new THREE.CylinderGeometry(0.05, 0.05, 6, 16);
        const spineMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const spine = new THREE.Mesh(spineGeo, spineMat);
        spine.rotation.x = Math.PI / 2; // Lie along Z axis
        bookGroup.add(spine);

        // --- Geometry Definitions ---
        const planeWidth = 4;
        const planeHeight = 4;
        
        function createRectGeometry() {
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                0, 0, -planeHeight/2,  
                planeWidth, 0, -planeHeight/2, 
                0, 0, planeHeight/2,   
                planeWidth, 0, planeHeight/2  
            ]);
            const indices = [0, 2, 1, 2, 3, 1]; 
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            return geometry;
        }

        function createTriGeometry() {
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                0, 0, -planeHeight/2, // Spine Top
                0, 0, planeHeight/2,  // Spine Bottom
                planeWidth, 0, 0      // Tip
            ]);
            const indices = [0, 1, 2];
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            return geometry;
        }

        function createIrregularTriGeometry(width, tipZOffset) {
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                0, 0, -planeHeight/2, // 0: Top
                0, 0, planeHeight/2,  // 1: Bottom
                width, 0, tipZOffset  // 2: Tip
            ]);
            const indices = [0, 1, 2];
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            return geometry;
        }

        const rectGeo = createRectGeometry();
        const triGeo = createTriGeometry();

        // Materials
        const matPlane1 = new THREE.MeshStandardMaterial({ 
            color: 0x60a5fa, 
            side: THREE.DoubleSide, 
            transparent: true, 
            opacity: 0.8,
            roughness: 0.1,
            metalness: 0.1
        });
        const matPlane2 = new THREE.MeshStandardMaterial({ 
            color: 0x4ade80, 
            side: THREE.DoubleSide, 
            transparent: true, 
            opacity: 0.8,
            roughness: 0.1,
            metalness: 0.1
        });

        const plane1 = new THREE.Mesh(rectGeo, matPlane1);
        const plane2 = new THREE.Mesh(rectGeo, matPlane2);
        bookGroup.add(plane1);
        bookGroup.add(plane2);

        // --- Thick Lines (Cylinders) ---

        function createThickLine(color) {
            const geometry = new THREE.CylinderGeometry(0.04, 0.04, 1, 8);
            const material = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            return mesh;
        }

        function updateThickLine(mesh, start, end) {
            const direction = new THREE.Vector3().subVectors(end, start);
            const length = direction.length();
            
            if (length < 0.001) {
                mesh.visible = false;
                return;
            }
            mesh.visible = true;

            mesh.position.copy(start).add(direction.clone().multiplyScalar(0.5));
            mesh.scale.set(1, length, 1);
            const axis = new THREE.Vector3(0, 1, 0); 
            mesh.quaternion.setFromUnitVectors(axis, direction.clone().normalize());
        }

        // True Lines (Perpendicular) - RED
        const trueLine1 = createThickLine(0xef4444);
        const trueLine2 = createThickLine(0xef4444);
        plane1.add(trueLine1);
        plane2.add(trueLine2);

        // Measured Lines (Diagonal/User) - YELLOW
        const measureLine1 = createThickLine(0xd97706);
        const measureLine2 = createThickLine(0xd97706);
        plane1.add(measureLine1);
        plane2.add(measureLine2);
        
        // Drift Lines (Optional visual guide)
        const driftLine1 = createThickLine(0x4b5563); 
        const driftLine2 = createThickLine(0x4b5563);
        driftLine1.visible = false; 
        driftLine2.visible = false;
        plane1.add(driftLine1);
        plane2.add(driftLine2);

        // Connector Line (World Space) - BLACK VERTICAL
        const connectorLine = createThickLine(0x000000);
        scene.add(connectorLine);

        // --- Sprites Helper ---
        function createTextSprite(message, fontSize = 60, color = "#111827") {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;
            
            ctx.fillStyle = "rgba(0,0,0,0)";
            ctx.fillRect(0,0,256,128);
            
            ctx.font = `Bold ${fontSize}px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = color;
            ctx.fillText(message, 128, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture, depthTest: false });
            const sprite = new THREE.Sprite(spriteMat);
            return sprite;
        }

        // --- Angle Visualization ---
        const angleVizGroup = new THREE.Group();
        scene.add(angleVizGroup);

        const arcGeo = new THREE.RingGeometry(1.2, 1.25, 32, 1, 0, 1);
        const arcMat = new THREE.MeshBasicMaterial({ color: 0x111827, side: THREE.DoubleSide });
        const angleArc = new THREE.Mesh(arcGeo, arcMat);
        angleVizGroup.add(angleArc);

        let angleLabelSprite = createTextSprite("60Â°", 80);
        angleLabelSprite.scale.set(1.5, 0.75, 1);
        angleVizGroup.add(angleLabelSprite);

        // --- Length Labels ---
        let lengthLabel1 = createTextSprite("10", 60, "#b91c1c"); 
        lengthLabel1.scale.set(1.5, 0.75, 1);
        scene.add(lengthLabel1);

        // Slicing Plane
        const sliceGeo = new THREE.PlaneGeometry(6, 6);
        const sliceMat = new THREE.MeshStandardMaterial({
            color: 0xa855f7, // Purple
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.2
        });
        const slicePlane = new THREE.Mesh(sliceGeo, sliceMat);
        slicePlane.visible = false;
        scene.add(slicePlane);


        // --- State ---
        const state = {
            angle: 45,
            skew: 0, 
            showSlice: false,
            shapeMode: 'rect-rect',
            irregularParams: {
                p1Width: 4,
                p1TipZ: 1.5,
                p2Width: 4, 
                p2TipZ: 0
            }
        };

        // --- 2D Canvas Drawing ---
        const ctx2d = document.getElementById('triangle-2d').getContext('2d');

        function draw2DRightTriangle(angleDeg, hypLength) {
            const w = ctx2d.canvas.width;
            const h = ctx2d.canvas.height;
            ctx2d.clearRect(0, 0, w, h);

            const startX = 40;
            const startY = h - 20;
            const scale = 7; // Pixels per unit length roughly (hypLength starts at 10)
            
            const angleRad = angleDeg * Math.PI / 180;
            
            // Hypotenuse length in px
            // 10 units = 100px roughly
            const hypPx = hypLength * 12; 
            
            // Calculate legs
            const basePx = hypPx * Math.cos(angleRad);
            const heightPx = hypPx * Math.sin(angleRad);
            
            // Draw Triangle
            ctx2d.beginPath();
            ctx2d.moveTo(startX, startY); // Origin
            ctx2d.lineTo(startX + basePx, startY); // Base
            ctx2d.lineTo(startX + basePx, startY - heightPx); // Top
            ctx2d.closePath(); // Back to Origin
            
            ctx2d.strokeStyle = "#4b5563";
            ctx2d.lineWidth = 2;
            ctx2d.fillStyle = "rgba(75, 85, 99, 0.1)";
            ctx2d.fill();
            ctx2d.stroke();
            
            // Draw Height Line (Black)
            ctx2d.beginPath();
            ctx2d.moveTo(startX + basePx, startY);
            ctx2d.lineTo(startX + basePx, startY - heightPx);
            ctx2d.strokeStyle = "#000000";
            ctx2d.lineWidth = 4;
            ctx2d.stroke();
            
            // Draw Hypotenuse (Yellow/Red)
            const isRed = (hypLength <= 10.1);
            ctx2d.beginPath();
            ctx2d.moveTo(startX, startY);
            ctx2d.lineTo(startX + basePx, startY - heightPx);
            ctx2d.strokeStyle = isRed ? "#ef4444" : "#d97706";
            ctx2d.lineWidth = 4;
            ctx2d.stroke();

            // Labels
            ctx2d.font = "bold 12px Arial";
            ctx2d.fillStyle = "#000000";
            ctx2d.textAlign = "left";
            ctx2d.fillText("Height", startX + basePx + 5, startY - heightPx/2);
            
            ctx2d.textAlign = "center";
            ctx2d.fillStyle = isRed ? "#ef4444" : "#d97706";
            ctx2d.fillText(hypLength, startX + basePx/2, startY - heightPx/2 - 5);
            
            // Angle
            ctx2d.fillStyle = "#000";
            ctx2d.fillText(`${angleDeg}Â°`, startX + 40, startY - 5);
        }


        // --- Update Function ---
        function updateSimulation() {
            // 1. Geometric Parameters
            let currentBaseZ = 0;
            let currentLineLen = 3;

            if (state.shapeMode === 'rect-rect') {
                plane1.geometry = rectGeo;
                plane2.geometry = rectGeo;
                document.getElementById('btn-randomize').classList.add('hidden');
            } else if (state.shapeMode === 'tri-rect') {
                plane1.geometry = triGeo;
                plane2.geometry = rectGeo;
                document.getElementById('btn-randomize').classList.add('hidden');
            } else if (state.shapeMode === 'tri-tri') {
                plane1.geometry = triGeo;
                plane2.geometry = triGeo;
                document.getElementById('btn-randomize').classList.add('hidden');
            } else if (state.shapeMode === 'tri-irregular') {
                if (plane1.geometry !== rectGeo && plane1.geometry !== triGeo) plane1.geometry.dispose();
                plane1.geometry = createIrregularTriGeometry(state.irregularParams.p1Width, state.irregularParams.p1TipZ);
                currentBaseZ = state.irregularParams.p1TipZ;
                currentLineLen = state.irregularParams.p1Width;
                
                if (plane2.geometry !== rectGeo && plane2.geometry !== triGeo) plane2.geometry.dispose();
                plane2.geometry = rectGeo; 
                document.getElementById('btn-randomize').classList.remove('hidden');
            }

            const angleRad = state.angle * Math.PI / 180;
            
            // 2. Rotate Planes
            plane2.rotation.z = 0; // Ground is fixed
            plane1.rotation.z = angleRad;

            // 3. World Calculations for Connector
            const zOffset = state.skew * 2; 
            const lift = 0.02;

            // Calculate Tip of Top Measured Line (Yellow/Red) in World Space
            // Local pos on Plane 1: (currentLineLen, lift, currentBaseZ + zOffset)
            const p1TipLocal = new THREE.Vector3(currentLineLen, lift, currentBaseZ + zOffset);
            const p1TipWorld = p1TipLocal.clone().applyMatrix4(plane1.matrixWorld);
            
            // Calculate Drop Point (Projection onto Ground / Plane 2)
            // Ground is at Y=0 (approx, Plane 2 is at Y=0)
            const pDropWorld = new THREE.Vector3(p1TipWorld.x, 0, p1TipWorld.z);
            
            // Spine Origin for this specific slice (on ground)
            const spineOriginWorld = new THREE.Vector3(0, 0, currentBaseZ + zOffset);

            // 4. Update Lines
            
            // Black Vertical Connector
            updateThickLine(connectorLine, p1TipWorld, pDropWorld);
            connectorLine.material.color.setHex(0x000000); // Strict black

            // Top Measured Line (Yellow)
            const skewStartLocal = new THREE.Vector3(0, lift, currentBaseZ); // Anchor at original Z
            const skewEndLocal = new THREE.Vector3(currentLineLen, lift, currentBaseZ + zOffset); // Tip drifted
            updateThickLine(measureLine1, skewStartLocal, skewEndLocal);
            
            // Calculate skew start in world for label positioning
            const skewStartWorld = skewStartLocal.clone().applyMatrix4(plane1.matrixWorld);

            // Recalculate World Tip based on skewed line
            const skewTipWorld = skewEndLocal.clone().applyMatrix4(plane1.matrixWorld);
            const skewDropWorld = new THREE.Vector3(skewTipWorld.x, 0, skewTipWorld.z);
            
            // Recalculate Connector
            updateThickLine(connectorLine, skewTipWorld, skewDropWorld);
            
            // Recalculate Shadow (Plane 2)
            // Connects Spine Start (Anchor) to Drop Point
            const m2ShadowStart = new THREE.Vector3(0, lift, currentBaseZ);
            const m2ShadowEnd = new THREE.Vector3(skewDropWorld.x, lift, skewDropWorld.z);
            updateThickLine(measureLine2, m2ShadowStart, m2ShadowEnd);
            
            // True Lines (Red)
            const t1StartLocal = new THREE.Vector3(0, lift, currentBaseZ);
            const t1EndLocal = new THREE.Vector3(currentLineLen, lift, currentBaseZ);
            updateThickLine(trueLine1, t1StartLocal, t1EndLocal);
            
            const t1TipWorld = new THREE.Vector3(currentLineLen, lift, currentBaseZ).applyMatrix4(plane1.matrixWorld);
            const tDropWorld = new THREE.Vector3(t1TipWorld.x, 0, t1TipWorld.z);
            
            const t2StartLocal = new THREE.Vector3(0, lift, currentBaseZ);
            const t2EndLocal = new THREE.Vector3(tDropWorld.x, lift, tDropWorld.z);
            updateThickLine(trueLine2, t2StartLocal, t2EndLocal);

            // 5. Measurements
            const geometricLength = Math.sqrt(currentLineLen*currentLineLen + zOffset*zOffset); // Hypotenuse (Simplified geometric, ignoring lift)
            const displayLength = ((geometricLength / currentLineLen) * 10).toFixed(1);
            
            // Calculate Observed Angle (Mathematically Perfect)
            // We calculate based on pure geometry, ignoring the visual "lift" offset
            // Height = L * sin(openAngle)
            // ProjX  = L * cos(openAngle)
            // Base   = sqrt(ProjX^2 + zOffset^2)
            
            const idealHeight = currentLineLen * Math.sin(angleRad);
            const idealProjX  = currentLineLen * Math.cos(angleRad);
            const idealBase   = Math.sqrt(idealProjX*idealProjX + zOffset*zOffset);
            
            const measuredAngleRad = Math.atan2(idealHeight, idealBase);
            const measuredAngleDeg = (measuredAngleRad * 180 / Math.PI).toFixed(1);

            // Update Text
            document.getElementById('display-line-length').textContent = displayLength;
            document.getElementById('display-measured-angle').textContent = `${measuredAngleDeg}Â°`;

            // Position Label
            // Use skewStartWorld (Start of line) and skewTipWorld (End of line)
            const labelPos = skewStartWorld.clone().add(skewTipWorld).multiplyScalar(0.5);
            labelPos.y += 0.3; // Slight lift above the line
            
            lengthLabel1.position.copy(labelPos);
            
            scene.remove(lengthLabel1);
            const newLbl = createTextSprite(displayLength, 60, state.skew < 0.1 ? "#059669" : "#dc2626");
            newLbl.scale.set(1.5, 0.75, 1);
            newLbl.position.copy(labelPos);
            lengthLabel1 = newLbl;
            scene.add(lengthLabel1);


            // 6. 2D & Visibility
            draw2DRightTriangle(measuredAngleDeg, displayLength);

            const statusMsg = document.getElementById('status-message');
            const skewLabel = document.getElementById('label-skew');

            if (state.skew < 0.1) {
                measureLine1.visible = false; 
                measureLine2.visible = false;
                trueLine1.visible = true;
                trueLine2.visible = true;
                
                statusMsg.className = "text-xs font-bold text-green-700 bg-green-100 p-2 rounded text-center";
                statusMsg.textContent = "CORRECT: Perpendicular";
                skewLabel.textContent = "Perpendicular";
                skewLabel.className = "text-green-600 font-bold";
                document.getElementById('display-measured-angle').className = "text-2xl font-bold text-green-600";
            } else {
                measureLine1.visible = true;
                measureLine2.visible = true;
                trueLine1.visible = true;
                trueLine1.material.opacity = 0.3; 
                trueLine1.material.transparent = true;
                trueLine2.visible = true;
                trueLine2.material.opacity = 0.3;
                trueLine2.material.transparent = true;

                statusMsg.className = "text-xs font-bold text-red-700 bg-red-100 p-2 rounded text-center";
                statusMsg.textContent = "DISTORTED: Skewed Line";
                skewLabel.textContent = "Diagonal / Oblique";
                skewLabel.className = "text-red-600 font-bold";
                document.getElementById('display-measured-angle').className = "text-2xl font-bold text-red-600";
            }
            
            // Slicing Plane
            const sliceAngle = Math.atan2(zOffset, skewDropWorld.x);
            slicePlane.rotation.set(0, 0, 0);
            slicePlane.rotation.y = -sliceAngle; 
            slicePlane.position.set(skewDropWorld.x/2, 1, currentBaseZ + zOffset/2);
            slicePlane.visible = state.showSlice;
            
            // Arc logic
            angleVizGroup.position.set(0, 0, currentBaseZ);
            angleVizGroup.rotation.set(0, -sliceAngle, 0); 
            
            const arcRadius = 1.5;
            angleArc.geometry.dispose();
            angleArc.geometry = new THREE.RingGeometry(arcRadius, arcRadius + 0.05, 32, 1, 0, measuredAngleRad);
            
            // Update Angle Label
            angleVizGroup.remove(angleLabelSprite);
            angleLabelSprite = createTextSprite(`${measuredAngleDeg}Â°`);
            const lx = (arcRadius + 0.6) * Math.cos(measuredAngleRad/2);
            const ly = (arcRadius + 0.6) * Math.sin(measuredAngleRad/2);
            angleLabelSprite.position.set(lx, ly, 0); 
            angleVizGroup.add(angleLabelSprite);
        }


        // --- Event Listeners ---
        document.getElementById('input-plane-angle').addEventListener('input', (e) => {
            state.angle = parseInt(e.target.value);
            document.getElementById('label-plane-angle').textContent = `${state.angle}Â°`;
            updateSimulation();
        });

        document.getElementById('input-skew').addEventListener('input', (e) => {
            state.skew = parseFloat(e.target.value);
            updateSimulation();
        });

        document.getElementById('toggle-slice').addEventListener('change', (e) => {
            state.showSlice = e.target.checked;
            updateSimulation();
        });

        document.getElementById('shape-select').addEventListener('change', (e) => {
            state.shapeMode = e.target.value;
            updateSimulation();
        });
        
        document.getElementById('btn-randomize').addEventListener('click', () => {
             state.irregularParams.p1Width = 3.5 + Math.random() * 1.5;
             state.irregularParams.p1TipZ = (Math.random() - 0.5) * 4;
             updateSimulation();
        });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        updateSimulation();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
